Class {
	#name : #LbRule,
	#superclass : #Object,
	#instVars : [
		'signature',
		'variables',
		'pattern',
		'condition'
	],
	#category : #'Leibniz-4-Rules'
}

{ #category : #converting }
LbRule >> asLeibnizSyntaxString [
	^ String streamContents: [ :s | self printAsLeibnizSyntaxOn: s ]
]

{ #category : #accessing }
LbRule >> condition [
	^ condition
]

{ #category : #copying }
LbRule >> deepCopy [
	^self
]

{ #category : #initializing }
LbRule >> initializeWithPattern: aPattern localVariables: aDictionary condition: aBooleanTerm [
	| patternVariables |
	pattern := aPattern.
	variables := aDictionary.
	condition := aBooleanTerm.
	signature := pattern signature.

	condition ifNotNil:
		[ self assert: condition signature equals: signature ].

	patternVariables := pattern variables.
	condition ifNotNil: [
		condition variables associationsDo: [ :each |
			self
				assert: (patternVariables includesAssociation: each)
				description: 'Variable ', each key asSymbol, ' in condition but not in pattern'  ] ].
]

{ #category : #rewriting }
LbRule >> match: aTerm [
	^ pattern match: aTerm.

]

{ #category : #accessing }
LbRule >> pattern [
	^ pattern
]

{ #category : #printing }
LbRule >> printOn: aStream [
	super printOn: aStream.
	aStream nextPut: $(.
	self printAsLeibnizSyntaxOn: aStream.
	aStream nextPut: $).
]

{ #category : #accessing }
LbRule >> signature [
	^ signature
]

{ #category : #accessing }
LbRule >> variables [
	^ variables
]
