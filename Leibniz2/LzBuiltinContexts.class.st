"
Builtin contexts are contexts that cannot be defined in Leibniz itself, because they make use of builtin terms such as numbers or strings. {{gtMethod:name=LzBuiltinContexts class>>#truthContext}} is an exception: it could very well be defined as a standard Leibniz context, but since it is used by the number contexts, it is part of the builtin contexts as well.

"
Class {
	#name : #LzBuiltinContexts,
	#superclass : #Object,
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #private }
LzBuiltinContexts class >> integerAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'โ ?x:โค โ ?y:โค  ?x + ?y = ?y + ?x';
		axiom: 'โ ?x:โค โ ?y:โค  โ ?z:โค  (?x + ?y) + ?z = ?x + (?y + ?z)';
		"multiplication axioms"
		axiom: 'โ ?x:โค โ ?y:โค  ?x ร ?y = ?y ร ?x';
		axiom: 'โ ?x:โค โ ?y:โค  โ ?z:โค  (?x ร ?y) ร ?z = ?x ร (?y ร ?z)'.
]

{ #category : #accessing }
LzBuiltinContexts class >> integerContext [
	| builder |
	builder := LzContextBuilder new
		include: self truthContext;
		builtin: #integers.
	self integerSortsFor: builder.
	self integerOpsFor: builder.
	self integerAxiomsFor: builder.
	self integerRulesFor: builder.
	^ builder context
]

{ #category : #private }
LzBuiltinContexts class >> integerOpsFor: aContextBuilder [
	aContextBuilder
		"Arithmetic operators"
		op: 'โค + โค : โค';
		op: 'โ + โ : โ';
		op: 'โ.nz + โ : โ.nz';
		op: 'โ + โ.nz : โ.nz';
		op: 'โค - โค : โค';
		op: '-(โค) : โค';
		op: 'โค ร โค : โค';
		op: 'โ ร โ : โ';
		op: 'โ.nz ร โ.nz : โ.nz';
		op: 'โค.nz ร โค.nz : โค.nz';
		op: 'โค div โค.nz : โค';
		op: 'โ div โ.nz : โ';
		op: 'โค rem โค.nz : โค';
		op: 'โ rem โ.nz : โ';
		op: 'โค^{โ.nz} : โค';
		op: 'โ^{โ.nz} : โ';
		op: 'โ.nz^{โ.nz} : โ.nz';
		op: 'โค.nz^{โ.nz} : โค.nz';
		op: 'โค.nz^{zero} : โ.nz';
		op: 'abs(โค) : โ';
		op: 'abs(โค.nz) : โ.nz';
		"Comparison operators"
		op: 'โค < โค : ๐น';
		op: 'โค > โค : ๐น';
		op: 'โค โค โค : ๐น';
		op: 'โค โฅ โค : ๐น'.
]

{ #category : #private }
LzBuiltinContexts class >> integerRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: 'โ ?x:โค โ ?zero:zero ?x + ?zero โ ?x';
		rule: 'โ ?x:โค โ ?zero:zero ?zero + ?x โ ?x';
		rule: 'โ ?x:โค โ ?y:โค ?x + ?y โ ''x + y'':LzIntegerTerm';
		"subtraction rules"
		rule: 'โ ?x:โค โ ?zero:zero ?x - ?zero โ ?x';
		rule: 'โ ?x:โค โ ?zero:zero ?zero - ?x โ -(?x)';
		rule: 'โ ?x:โค โ ?y:โค ?x - ?y โ ''x - y'':LzIntegerTerm';
		rule: 'โ ?zero:zero -(?zero) โ 0';
		rule: 'โ ?x:โค -(?x) โ ''x negated'':LzIntegerTerm';
		"multiplication rules"
		rule: 'โ ?x:โค โ ?zero:zero ?x ร ?zero โ 0';
		rule: 'โ ?x:โค โ ?zero:zero ?zero ร ?x โ 0';
		rule: 'โ ?x:โค 1 ร ?x โ ?x';
		rule: 'โ ?x:โค ?x ร 1 โ ?x';
		rule: 'โ ?x:โค โ ?y:โค ?x ร ?y โ ''x * y'':LzIntegerTerm';
		"division rules"
		rule: 'โ ?x:โค.nz โ ?zero:zero ?zero div ?x โ 0';
		rule: 'โ ?x:โค ?x div 1 โ ?x';
		rule: 'โ ?x:โค โ ?y:โค.nz ?x div ?y โ ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: 'โ ?x:โค.nz โ ?zero:zero ?zero rem ?x โ 0';
		rule: 'โ ?x:โค ?x rem 1 โ 0';
		rule: 'โ ?x:โค โ ?y:โค.nz ?x rem ?y โ ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"exponentiation rules"
		rule: 'โ ?x:โค.nz โ ?zero:zero ?x^{?zero} โ 1';
		rule: 'โ ?x:โ.nz โ ?zero:zero ?zero^{?x} โ 0';
		rule: 'โ ?x:โค โ ?y:โ.nz ?x^{?y} โ ''x raisedTo: y'':LzIntegerTerm';
		"abs rules"
		rule: 'โ ?x:โ abs(?x) โ ?x';
		rule: 'โ ?x:โค abs(?x) โ -(?x) | ?x < 0';
		rule: 'โ ?x:โค abs(?x) โ ''x abs'':LzIntegerTerm';
		"comparison rules"
		rule: 'โ ?x:โค โ ?y:โค ?x < ?y โ ''x < y'':LzBooleanTerm';
		rule: 'โ ?x:โค โ ?y:โค ?x > ?y โ ''x > y'':LzBooleanTerm';
		rule: 'โ ?x:โค โ ?y:โค ?x โค ?y โ ''x <= y'':LzBooleanTerm';
		rule: 'โ ?x:โค โ ?y:โค ?x โฅ ?y โ ''x >= y'':LzBooleanTerm'.
]

{ #category : #private }
LzBuiltinContexts class >> integerSortsFor: aContextBuilder [
	aContextBuilder
		"Natural numbers"
		sort: 'โ';
		sort: 'โ.nz';
		sort: 'zero';
		subsort: 'zero โ โ';
		subsort: 'โ.nz โ โ';
		"Integers"
		sort: 'โค';
		sort: 'โค.nz';
		subsort: 'โ โ โค';
		subsort: 'โค.nz โ โค';
		subsort: 'โ.nz โ โค.nz'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'โ ?x:โ โ ?y:โ  ?x + ?y = ?y + ?x';
		axiom: 'โ ?x:โ โ ?y:โ  โ ?z:โ  (?x + ?y) + ?z = ?x + (?y + ?z)';
		"multiplication axioms"
		axiom: 'โ ?x:โ โ ?y:โ  ?x ร ?y = ?y ร ?x';
		axiom: 'โ ?x:โ โ ?y:โ  โ ?z:โ  (?x ร ?y) ร ?z = ?x ร (?y ร ?z)'.
]

{ #category : #accessing }
LzBuiltinContexts class >> rationalNumberContext [
	| builder |
	builder := LzContextBuilder new
		include: self truthContext;
		builtin: #integers;
		builtin: #rationalNumbers.
	self integerSortsFor: builder.
	self rationalSortsFor: builder.
	self integerOpsFor: builder.
	self rationalOpsFor: builder.
	"No integerAxioms, because they would be redundant."
	self rationalAxiomsFor:  builder.
	"No integerRules, the few that are required are repeated in rationalRules."
	self rationalRulesFor: builder.
	^ builder context
]

{ #category : #private }
LzBuiltinContexts class >> rationalOpsFor: aContextBuilder [
	aContextBuilder
		"Arithmetic operators"
		op: 'โ + โ : โ';
		op: 'โ.p + โ.p : โ.p';
		op: 'โ.nn + โ.nn : โ.nn';
		op: 'โ - โ : โ';
		op: '-(โ) : โ';
		op: 'โ ร โ : โ';
		op: 'โ.p ร โ.p : โ.p';
		op: 'โ.nn ร โ.nn : โ.nn';
		op: 'โ.nz ร โ.nz : โ.nz';
		op: 'โ รท โ.nz : โ';
		op: 'โ.nz รท โ.nz : โ.nz';
		op: 'โ.nn รท โ.p : โ.nn';
		op: 'โ.p รท โ.p : โ.p';
		op: 'โ.nz^{โค.nz} : โ.nz';
		op: 'โ.p^{โค.nz} : โ.p';
		op: 'โ.nz^{zero} : โ.nz';
		op: 'abs(โ) : โ.nn';
		op: 'abs(โ.nz) : โ.p';
		"Comparison operators"
		op: 'โ < โ : ๐น';
		op: 'โ > โ : ๐น';
		op: 'โ โค โ : ๐น';
		op: 'โ โฅ โ : ๐น'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: 'โ ?x:โ โ ?z:zero ?x + ?z โ ?x';
		rule: 'โ ?x:โ โ ?z:zero ?z + ?x โ ?x';
		rule: 'โ ?x:โ โ ?y:โ ?x + ?y โ ''x + y'':LzRationalNumberTerm';
		rule: 'โ ?x:โค โ ?y:โค ?x + ?y โ ''x + y'':LzIntegerTerm';
		"Subtraction rules"
		rule: 'โ ?x:โ โ ?z:zero ?x - ?z โ ?x';
		rule: 'โ ?x:โ โ ?z:zero ?z - ?x โ -(?x)';
		rule: 'โ ?x:โค โ ?y:โค ?x - ?y โ ''x - y'':LzIntegerTerm';
		rule: 'โ ?x:โ โ ?y:โ ?x - ?y โ ''x - y'':LzRationalNumberTerm';
		"Negation rules"
		rule: 'โ ?z:zero -(?z) โ 0';
		rule: 'โ ?x:โค -(?x) โ ''x negated'':LzIntegerTerm';
		rule: 'โ ?x:โ -(?x) โ ''x negated'':LzRationalNumberTerm';
		"Multiplication rules"
		rule: 'โ ?x:โ โ ?z:zero ?x ร ?z โ 0';
		rule: 'โ ?x:โ โ ?z:zero ?z ร ?x โ 0';
		rule: 'โ ?x:โ 1 ร ?x โ ?x';
		rule: 'โ ?x:โ ?x ร 1 โ ?x';
		rule: 'โ ?x:โค โ ?y:โค ?x ร ?y โ ''x * y'':LzIntegerTerm';
		rule: 'โ ?x:โ โ ?y:โ ?x ร ?y โ ''x * y'':LzRationalNumberTerm';
		"Division rules"
		rule: 'โ ?x:โ.nz โ ?z:zero ?z รท ?x โ 0';
		rule: 'โ ?x:โ ?x รท 1 โ ?x';
		rule: 'โ ?x:โ โ ?y:โ.nz ?x รท ?y โ ''x / y'':LzRationalNumberTerm';
		"Integer div and rem rules"
		rule: 'โ ?x:โค.nz โ ?z:zero ?z div ?x โ 0';
		rule: 'โ ?x:โค ?x div 1 โ ?x';
		rule: 'โ ?x:โค โ ?y:โค.nz ?x div ?y โ ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: 'โ ?x:โค.nz โ ?z:zero ?z rem ?x โ 0';
		rule: 'โ ?x:โค ?x rem 1 โ 0';
		rule: 'โ ?x:โค โ ?y:โค.nz ?x rem ?y โ ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"Exponentiation rules"
		rule: 'โ ?x:โ.nz โ ?z:zero ?x^{?z} โ 1';
		rule: 'โ ?x:โ.nz โ ?z:zero ?z^{?x} โ 0';
		rule: 'โ ?x:โค โ ?y:โ.nz ?x^{?y} โ ''x raisedTo: y'':LzIntegerTerm';
		rule: 'โ ?x:โ.nz โ ?y:โค.nz ?x^{?y} โ ''x raisedTo: y'':LzRationalNumberTerm';
		"Abs rules"
		rule: 'โ ?x:โ.nn abs(?x) โ ?x';
		rule: 'โ ?x:โ abs(?x) โ -(?x) | ?x < 0';
		rule: 'โ ?x:โค abs(?x) โ ''x abs'':LzIntegerTerm';
		rule: 'โ ?x:โ abs(?x) โ ''x abs'':LzRationalNumberTerm';
		"Comparison rules"
		rule: 'โ ?x:โ โ ?y:โ ?x < ?y โ ''x < y'':LzBooleanTerm';
		rule: 'โ ?x:โ โ ?y:โ ?x > ?y โ ''x > y'':LzBooleanTerm';
		rule: 'โ ?x:โ โ ?y:โ ?x โค ?y โ ''x <= y'':LzBooleanTerm';
		rule: 'โ ?x:โ โ ?y:โ ?x โฅ ?y โ ''x >= y'':LzBooleanTerm'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalSortsFor: aContextBuilder [
	aContextBuilder
		"Rational numbers"
		sort: 'โ';
		sort: 'โ.nn';
		sort: 'โ.nz';
		sort: 'โ.p';
		subsort: 'โ.nz โ โ';
		subsort: 'โ.p โ โ.nz';
		subsort: 'โ.nn โ โ';
		subsort: 'โ.p โ โ.nn';
		subsort: 'โ โ โ.nn';
		subsort: 'โ.nz โ โ.p';
		subsort: 'โค โ โ';
		subsort: 'โค.nz โ โ.nz'.
]

{ #category : #accessing }
LzBuiltinContexts class >> sortContext [
	^ LzSortHierarchyRoot uniqueInstance sortContext
]

{ #category : #accessing }
LzBuiltinContexts class >> stringContext [
	^ LzContextBuilder new
		builtin: #strings;
		sort: 'string';
		op: 'string + string : string';
		rule: 'โ ?a:string โ ?b:string ?a + ?b โ ''a, b'':LzStringTerm';
		context
]

{ #category : #accessing }
LzBuiltinContexts class >> truthContext [
	^ LzContextBuilder new
		sort: '๐น';
		op: 'โค : ๐น';
		op: 'โฅ : ๐น';
		context
]
