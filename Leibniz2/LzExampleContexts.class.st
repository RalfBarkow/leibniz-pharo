"
The contexts defined in the methods of this class are standard Leibniz contexts. They are provided because they are useful and/or because they are used in other example code.
"
Class {
	#name : #LzExampleContexts,
	#superclass : #Object,
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #defining }
LzExampleContexts class >> booleanContext [
	| builder |
	builder := LzContextBuilder new
		include: LzBuiltinContexts truthContext;
		op: '¬(𝔹) : 𝔹';
		op: '𝔹 ∧ 𝔹 : 𝔹';
		op: '𝔹 ∨ 𝔹 : 𝔹';
		op: '𝔹 ⊻ 𝔹 : 𝔹';
		axiom: '∀ x_:𝔹 ∀ y_:𝔹 x_ ∧ y_ = y_ ∧ x_';
		axiom: '∀ x_:𝔹 ∀ y_:𝔹 ∀ z_:𝔹 (x_ ∧ y_) ∧ z_ = x_ ∧ (y_ ∧ z_)';
		axiom: '∀ x_:𝔹 ∀ y_:𝔹 x_ ∨ y_ = y_ ∨ x_';
		axiom: '∀ x_:𝔹 ∀ y_:𝔹 ∀ z_:𝔹 (x_ ∨ y_) ∨ z_ = x_ ∨ (y_ ∨ z_)';
		axiom: '∀ x_:𝔹 ∀ y_:𝔹 x_ ⊻ y_ = y_ ⊻ x_';
		axiom: '∀ x_:𝔹 ∀ y_:𝔹 ∀ z_:𝔹 (x_ ⊻ y_) ⊻ z_ = x_ ⊻ (y_ ⊻ z_)'.
	self booleanRulesFor: builder.
	^ builder context
]

{ #category : #private }
LzExampleContexts class >> booleanRulesFor: builder [
	builder
		"1. Eliminate NOT and OR"

		"1a. NOT is replaced by XOR with ⊤"
		rule: '∀ x_:𝔹 ¬(x_) ⇒ ⊤ ⊻ x_';

		"1b. OR is replaced by XOR and AND"
		rule: '∀ y_:𝔹  ∀ x_:𝔹 x_ ∨ y_ ⇒ x_ ⊻ y_ ⊻ (x_ ∧ y_)';

		"2 Simplify AND relations"

		"2a. AND is ⊥ if one of its arguments is ⊥"
		rule: '∀ x_:𝔹 x_ ∧ ⊥ ⇒ ⊥';
		rule: '∀ x_:𝔹 ⊥ ∧ x_ ⇒ ⊥';

		"2b. If one argument of AND is ⊤, the result is the other argument"
		rule: '∀ x_:𝔹 x_ ∧ ⊤ ⇒ x_';
		rule: '∀ x_:𝔹 ⊤ ∧ x_ ⇒ x_';

		"2c. If the two arguments to AND are equal, they are also equal to the result"
		rule: '∀ x_:𝔹 x_ ∧ x_ ⇒ x_';

		"3 Simplify XOR relations"

		"3a. XOR with ⊥ leaves truth values unchanged"
		rule: '∀ x_:𝔹 x_ ⊻ ⊥ ⇒ x_';
		rule: '∀ x_:𝔹 ⊥ ⊻ x_ ⇒ x_';

		"3b. If the two arguments to XOR are equal, the result is ⊥"
		rule: '∀ x_:𝔹 x_ ⊻ x_ ⇒ ⊥';

		"4. Standardize combinations of XOR and AND"
		rule: '∀ x_:𝔹 ∀ y_:𝔹 ∀ z_:𝔹 x_ ∧ (y_ ⊻ z_) ⇒ (x_ ∧ y_) ⊻ (x_ ∧ z_)'.
]

{ #category : #private }
LzExampleContexts class >> collectionConstructorOpsFor: builder [
	builder
		op: '∅ : ∅';
		op: '∀ s_:𝕊 ∀ n_:ℕ ∀ m_:ℕ ',
				'(list(s_, n_)) ++ (list(s_, m_)) : list(s_, n_ + m_)';
		op: '∀ s_:𝕊 ',
				'(list(s_)) ++ (list(s_)) : list(s_)';
		op: '∀ s_:𝕊 ∀ n_:ℕ ∀ m_:ℕ ',
				'(bag(s_, n_)) ++ (bag(s_, m_)) : bag(s_, n_ + m_)';
		op: '∀ s_:𝕊 ',
				'(bag(s_)) ++ (bag(s_)) : bag(s_)';
		op: '∀ s_:𝕊 ',
				'(set(s_)) ++ (set(s_)) : set(s_)';
		op: '∀ s_:𝕊 ∀ n_:ℕ ',
				'(list(s_, n_)) ++ s_ : list(s_, n_ + 1)';
		op: '∀ s_:𝕊 ∀ n_:ℕ ',
				'(bag(s_, n_)) ++ s_ : bag(s_, n_ + 1)';
		op: '∀ s_:𝕊 ',
				'(list(s_)) ++ s_ : list(s_)';
		op: '∀ s_:𝕊 ',
				'(bag(s_)) ++ s_ : bag(s_)';
		op: '∀ s_:𝕊 ',
				'(set(s_)) ++ s_ : set(s_)';
		op: '∀ s_:𝕊 ',
				'∅ ++ s_ : list(s_, 1)';
		op: '∀ s_:𝕊 ',
				'singleton(s_) : list(s_, 1)'
]

{ #category : #defining }
LzExampleContexts class >> collectionContext [
	| builder |
	builder := LzContextBuilder new
		includeSortContext: LzBuiltinContexts integerContext.
	self collectionSortsFor: builder. 
	self collectionConstructorOpsFor: builder.
	self constructionAccessorsFor: builder.
	^ builder context
]

{ #category : #private }
LzExampleContexts class >> collectionSortsFor: builder [
	builder
		sort: 'collection';
		sort: '∅';
		subsort: '∅ ⊆ collection';
		sort: 'list(𝕊, ℕ)';
		sort: 'bag(𝕊, ℕ)';
		sort: 'list(𝕊)';
		sort: 'bag(𝕊)';
		sort: 'set(𝕊)';
		subsort: '∀ s_:𝕊 ∀ n_:ℕ list(s_, n_) ⊆ bag(s_, n_)';
		subsort: '∀ s_:𝕊 ∀ n_:ℕ list(s_, n_) ⊆ list(s_)';
		subsort: '∀ s_:𝕊 ∀ n_:ℕ bag(s_, n_) ⊆ bag(s_)';
		subsort: '∀ s_:𝕊 list(s_) ⊆ bag(s_)';
		subsort: '∀ s_:𝕊 bag(s_) ⊆ set(s_)';
		subsort: '∀ s_:𝕊 set(s_) ⊆ collection'
]

{ #category : #private }
LzExampleContexts class >> constructionAccessorsFor: builder [
	builder
		op: '∀ s_:𝕊 ∀ n_:ℕ.nz ',
				'allButLast(list(s_, n_)) : list(s_, pred(n_))';
		rule: '∀ s__:𝕊 ∀ n__:ℕ ∀ l_:list(s__, n__) ∀ e_:s__ ',
				'allButLast(l_ ++ e_) ⇒ l_';
		op: '∀ s_:𝕊 ∀ n_:ℕ.nz ',
				'last(list(s_, n_)) : s_';
		rule: '∀ s__:𝕊 ∀ n__:ℕ ∀ l_:list(s__, n__) ∀ e_:s__ ',
				'last(l_ ++ e_) ⇒ e_'
]

{ #category : #defining }
LzExampleContexts class >> functionContext [
	^ LzContextBuilder new
		sort: '∀ from_:𝕊 ∀ to_:𝕊 ',
				'fn(from_, to_)';
		op: '∀ from_:𝕊 ∀ to_:𝕊 ',
				'(fn(from_, to_))[from_] : to_';
		context
]

{ #category : #defining }
LzExampleContexts class >> mapContext [
	^ LzContextBuilder new
		include: self functionContext;
		include: self collectionContext;
		op: '∀ from_:𝕊 ∀ to_:𝕊 ∀ n_:ℕ ',
			'map(fn(from_, to_), list(from_, n_)) : list(to_, n_)';
		op: '∀ from_:𝕊 ∀ to_:𝕊 ∀ n_:ℕ ',
			'map(fn(from_, to_), ∅) : ∅';
		rule: '∀ from__:𝕊 ∀ to__:𝕊 ∀ f_:fn(from__, to__) ',
				'∀ n__:ℕ ∀ l_:list(from__, n__) ∀ e_:from__ ',
				'map(f_, l_ ++ e_) ⇒ map(f_, l_) ++ f_[e_]';
		rule: '∀ from__:𝕊 ∀ to__:𝕊 ∀ f_:fn(from__, to__) ',
				'∀ e_:from__ ',
				'map(f_, ∅ ++ e_) ⇒ ∅ ++ f_[e_]';
		rule: '∀ from__:𝕊 ∀ to__:𝕊 ∀ f_:fn(from__, to__) ',
				'map(f_, ∅) ⇒ ∅';
		context
]
